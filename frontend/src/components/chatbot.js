import React from "react";
import * as Icon from "react-feather";
import $ from "jquery";
import _ from "lodash";

import Progress from "react-progressbar";

import axios from "axios";
import { BACKEND_URL_DEV, ENDPOINT, languages } from "../config";

import PeerConnection from "./webrtc/PeerConnection";
import CallWindow from "./webrtc/CallWindow";
import CallModal from "./webrtc/CallModal";

const bson = require('bson');
const { commands } = require('../data/commands'); // TODO: Should be fetched from backend or be executed at the backend via APIs
const client = require('socket.io-client');

const TYPE_TEXT = 'text'
const TYPE_BUTTON = 'button'
const TYPE_LIST = 'list'										// checkboxes
const TYPE_SELECT = 'select'
const TYPE_UPLOAD = 'upload'
// const TYPE_MULTI_SELECT = 'multi_select'
const TYPE_NONE = "none"                    // send a message and move to next message. Or run a command
const TYPE_ANALYSE = "analyse"              // complex analyses of user answers on frontend. example cardiac screening

const MUTE_ALL = 'muteall'
const SPEAK_ALL = 'speakall'
// const STOP_SPEECH = 'stop'

const INCOMING_MESSAGE = 'incoming'					// sent by bot or doctor
const OUTGOING_MESSAGE = 'outgoing'					// sent by user/patient

//Incoming message : chatbot server to user

export default class Chat extends React.Component {
	state = {
		conversation_session_id: '',
		questions: [],
		answers: {},
		timestamps: {},
		messageReceivedTimestamp: null,
		currentQuestion: {},

		languageSelected: 'hi', // TODO: Save and load from cookie
		helpline: '011-23978046', // TODO: Fetch location specific ambulance numbers

		optionSelected: '0',
		textAnswered: '',
		textOverrideAnswered: '',

		chat: [],
		loadingChat: true,
		requesting: false,

		connectToDoctor: false,

		patientId: null,
		doctor: null,
		incomingTyping: false,

		answerBoxHidden: true,
		answerFormat: {}, // instructions for presenting and receiving the answer to the user
		questionDetails: {},

		callWindow: '',
		callModal: '',
		localSrc: null,
		peerSrc: null,

		mute: SPEAK_ALL
	};

	socket = null;
	pc = {};

	componentDidMount() {
		// generate sessionID for mongodb.
		this.state.conversation_session_id = new bson.ObjectId().toString();

		this.realtime()

		// axios
		// 	.get(ENDPOINT + '/api/questions')
		// 	.then((response) => {
		// 		const { questions, incomingChats } = response.data;
		// 		if (questions)
		// 			this.setState(
		// 				{
		// 					questions,
		// 					chat: incomingChats,
		// 					loadingChat: false
		// 				},
		// 				() => {
		// 					this.setQuestion(questions[0]);
		// 				}
		// 			);
		// 	})
		// 	.catch((error) => {
		// 		// this.setState({ loadingChat: false });
		// 		console.log(error);
		// 	});

    // navigator.geolocation.getCurrentPosition(
    //   this.getHelpline.bind(this)
    // );

	}

	componentWillUnmount() {
		if (this.socket) this.socket.disconnect();
	}

  /**
	 * sets different types of questions - configures variables to be used later
   * @param question Either a question object or a question ID
   * @param customOptions Overrides the existing options
	 * Sends information to the backend with every message
	 * Adds the statements in the memory
   */
	setQuestion = (question, customOptions=null) => {
		// if ID, get object
    if (typeof question == "number" || typeof question == "string") {
      question = this.getQuestionById(question);
    }
    const { answers } = this.state;					// contains question ID and value of user input
		let { statement, type: type, options, pattern, id, nextQuestion, paramsFrom, command, branches, loopStart } = question;
		console.log("statement = ", statement)

		if (customOptions) {
      options = customOptions;
    }

    if (typeof statement != 'string') {
			this.speak(statement[this.state.languageSelected], false)
		// conversation is added in the memory here
      for (let key in statement) {
				statement[key] = this.insertVariables(statement[key]);
			}
    } else {
      statement = this.insertVariables(statement);
    }
    if (typeof options == 'string') {
      // Options generated by a command
      options = commands[options](answers, question, this.setQuestion);
    }
		let tempSelection = this.state.tempSelection;
		if (type === 'list') {
			tempSelection = {};
			for (let i = 0; i < options.length; ++i) {
				tempSelection[i] = false;
			}
		}
		this.enterMessageIntoChat(statement, INCOMING_MESSAGE);
		// this.realtime({
		// 	language: this.state.languageSelected,
		// 	statement:statement,
		// 	direction:INCOMING_MESSAGE,
		// 	message_type: type,
		// 	id:id,
		// 	nextQuestion: nextQuestion,
		// 	command:command,
		// 	branches:branches,
		// 	options:options,
		// 	textAnswered: this.answerEntered,
		// 	tempSelection:tempSelection
		// })
		this.setState({
			answerBoxHidden: type===TYPE_NONE,
			textAnswered: '',
			optionSelected: '0',
			answerFormat: { type: type, options, pattern },
			questionDetails: { loopStart, statement, id, nextQuestion, paramsFrom, command, branches },
			tempSelection: tempSelection
		});
    if (type === TYPE_NONE && command) {
			// run a task/command
      //commands[command](answers, question, this.setQuestion);
      this.realtime()
    }
		else if (type === TYPE_ANALYSE && command) {
			// run a task/command
			const { questions } = this.state;
			//commands[command](answers, question, questions, this.setQuestion);
      this.realtime()
		}
		else if (type === TYPE_NONE && nextQuestion) {
			// simple statement
      // Without delay, the present question may not get rendered
      setTimeout(function() {
				console.log("simple statement. nextQuestion = ", nextQuestion)
        if (this.questions!==undefined) this.setQuestion(nextQuestion);
				else this.realtime();
      }.bind(this), 1000)
    }
		else {
			// console.error("unexpected situation in setQuestion");
		}
	};

	/**
	 * formats the data of statement and associated data of message
	 */
  insertVariables(statement) {
    let formattedStatement = statement;
    while (formattedStatement.search('{.*}') !== -1) {
      formattedStatement = this.insertVariable(formattedStatement);
    }
    return formattedStatement;
  };

  insertVariable(statement) {
    let formattedStatement = statement;
    let start = statement.search('{.*}');
    if (start !== -1) {
      let end = statement.search('}');
      formattedStatement = statement.replace(
        statement.substring(start, end+1),
        this.state[statement.substring(start+1, end)]);
    }
    return formattedStatement;
  };

	/**
	 * Add message of any kind to the json and update UI
	 */
	enterMessageIntoChat = (statement, direction) => {
		const { chat } = this.state;
		this.setState(
			{
				chat: chat.concat([{ statement, type: direction }])
			},
			this.scrollDown
		);
	};

	/*
	 * Return question object from questions list
	 */
	getQuestionById = (id) => {
		const { questions, currentQuestion } = this.state;
		// realtime. messages are received on the fly
		if (id === undefined){
			return currentQuestion
		}

		// offline. entire question bank is received. and decisions are made at the client
		for (let i = 0; i < questions.length; i++) {
			if (questions[i].id === id) return questions[i];
		}

		console.error("failed to search for question with ID = ", id)
		return null;
	};

	/**
	 * UI
	 */
	scrollDown = () => {
		let x = $('#chat-box')
		if (x.length)
			x.animate({ scrollTop: x[0].scrollHeight }, 800);
	};

	/**
	 * Sends on send button press. Attached to form. Uses socket
	 */
	sendMessage = (event) => {
		const { textAnswered, doctor } = this.state;

		if (event && event.preventDefault) event.preventDefault();

		if (textAnswered.length) {
			this.setState({ textAnswered: '' });
			this.socket.emit('message', { message: textAnswered, to: doctor });
			this.enterMessageIntoChat(textAnswered, OUTGOING_MESSAGE);
		}
	};

	// used while uploading image
	handleMessageChange = (event) => {
		const { id, value } = event.target;
		const { textAnswered, doctor } = this.state;

		this.setState({
			[id]: value
		});

		if ((value.length === 0) ^ (textAnswered.length === 0)) {
			this.socket.emit('typingChange', { state: value.length > 0, to: doctor });
		}
	};

	/**
	 * For doctor-patient interaction
	 * For call or only messages?
	 * Primarily for the doctor
	 */
	connect = () => {
		const { patientId } = this.state;

		this.setState({ requesting: true });

		// create socket based on environment - dev/prod
		this.socket = client(process.env.NODE_ENV === 'development' ? BACKEND_URL_DEV : '/', {
			path: '/app_chat',
			transports: ['websocket'],
			query: {
				patientId,
				type: 'patient'
			}
		});

		this.socket.on('doctorAlloted', (doctor) => {
			this.setState({
				answerBoxHidden: false,
				requesting: false,
				doctor
			});
		});

		this.socket.on('onlineUsers', (onlineUsers) => {
			this.setState({ onlineUsers });
		});

		this.socket.on('message', ({ message, from }) => {
			if (from === this.state.doctor) {
				this.setState({ incomingTyping: false });
				this.enterMessageIntoChat(message, 'incoming');
			}
		});

		this.socket.on('typingChange', ({ state, from }) => {
			if (from === this.state.doctor) {
				this.setState({ incomingTyping: state });
				this.scrollDown();
			}
		});

		this.socket.on('referUser', (doctor) => {
			this.endCall(false);
			this.setState({ doctor, answerBoxHidden: true });
		});

		this.socket.on('request', (from) => {
			if (from === this.state.doctor) {
				this.setState({ callModal: 'active' });
				this.scrollDown();
			}
		});

		this.socket.on('call', ({ data, from }) => {
			if (from === this.state.doctor) {
				if (data.sdp) {
					this.pc.setRemoteDescription(data.sdp);
					if (data.sdp.type === 'offer') this.pc.createAnswer();
				} else this.pc.addIceCandidate(data.candidate);
			}
		});

		this.socket.on('end', (from) => {
			if (from === this.state.doctor) this.endCall(false);
		});
	};

	startCall = (isCaller, config) => {
		this.config = config;
		this.pc = new PeerConnection(this.socket, this.state.doctor)
			.on('localStream', (src) => {
				const newState = { callWindow: 'active', localSrc: src };
				if (!isCaller) newState.callModal = '';
				this.setState(newState);
			})
			.on('peerStream', (src) => this.setState({ peerSrc: src }))
			.start(isCaller, config);
	};

	rejectCall = () => {
		const { doctor } = this.state;
		this.socket.emit('end', doctor);
		this.setState({ callModal: '' });
	};

	endCall = (isStarter) => {
		if (_.isFunction(this.pc.stop)) {
			this.pc.stop(isStarter);
		}
		this.pc = {};
		this.config = null;
		this.setState(
			{
				callWindow: '',
				callModal: '',
				localSrc: null,
				peerSrc: null
			},
			this.scrollDown
		);
	};

	answer = (event, textOverrides) => {
		console.debug('answer()')
		const { optionSelected, questionDetails, answerFormat, answers, tempSelection } = this.state;
		const { options, type } = answerFormat;
		// noinspection JSUnusedLocalSymbols
		const { id, paramsFrom, branches, loopStart } = questionDetails;
		let { textAnswered, textOverrideAnswered, reset } = this.state;
		let textTypeAnswer = ['text', 'tel', 'password', 'email', 'date'].includes(type);

		// prevent Default followup to the event. No idea when?
		if (event && event.preventDefault) event.preventDefault();

		if (type === TYPE_LIST) {
			// Don't do much other than update things
			textTypeAnswer = true;
			textAnswered = "";
			let savedValues = [];
			for (let i = 0; i < options.length; ++i) {
				let statement = (typeof options[i].statement === "string")
	        ? options[i].statement
	        : options[i].statement[this.state.languageSelected];
				if (tempSelection[i]) {
					textAnswered += statement + ", ";
					savedValues.push(options[i].dbValue);
				}
			}
			if (textAnswered === "") textAnswered = "None"
			else textAnswered = textAnswered.substring(0, textAnswered.length-2);
			this.enterMessageIntoChat(
				textTypeAnswer ? textAnswered : options[optionSelected].statement,
				OUTGOING_MESSAGE
			);
			console.log('type = list')
			this.setState(
				{answers: {
						...this.state.answers,
						[id]: savedValues
					},
					answerBoxHidden: true,
					timestamps: {
						...this.state.timestamps,
						[id]: Date.now()
					}
				},
				this.answerEntered
			);
		}
		else if (reset){
			console.log('chatbot.answer : reset = ', reset)
			this.realtime()
			// this.setState(this.state, this.answerEntered)
		}
		else if ((!textTypeAnswer || textAnswered) && (!textOverrides)) {
			// accept as an answer if type is not text.
			console.log('textOverrides = ', textOverrides)

			if (type === 'password') {
    	    this.enterMessageIntoChat('****', OUTGOING_MESSAGE);
		  }
			else if (type !== TYPE_NONE) {
				console.debug('answer() type != none')
				// button
				this.enterMessageIntoChat(
					textTypeAnswer ? textAnswered : options[optionSelected].statement,
					OUTGOING_MESSAGE
				);
			}
  		let value = textTypeAnswer ? textAnswered : options[optionSelected].value;
  		if (loopStart) {
  			value = [value];
  			if (answers[id]) {
  				value = [...answers[id], ...value];
			  }
  		}
			this.setState(
				{answers: {																								// push a value into answers
						...this.state.answers,
						[id]: value
					},
					answerBoxHidden: true,
					timestamps: {
						...this.state.timestamps,
						[id]: Date.now()
					}
				},
				this.answerEntered
			);
		} else {
			console.debug('answer() default fallback')
		}
	};

	/*
	 * called when bot completes questionnaire and is passed in user's physical location
	 * posts to the assessment api
	 */
	completedChatbot = (position) => {
		const { latitude, longitude } = (position && position.coords) || {};
		const { chat, answers, timestamps, conversation_session_id } = this.state;

		this.setState({ requesting: true });

    // Save the statements in the selected language.
		const chatToSave = this.saveChatStatements(chat);

		/*
		 * send the chat to the server and push into DB.
		 * run the assessment code
		 */
		axios
			.post(ENDPOINT + '/api/assessment', {
				answers,
				timestamps,
				latitude,
				longitude,
				chat: chatToSave,
				conversation_session_id
			})
			.then((response) => {
				console.log("api/assessment contacted")
				const { incomingChats, connectToDoctor, patientId, question } = response.data;		// messages fetched here
				if (connectToDoctor) {
					console.log('connectToDoctor = ', connectToDoctor)
					this.setState(
						{
							connectToDoctor,
							patientId,
							chat: chat.concat(incomingChats)
						},
						this.scrollDown
					);
					this.setQuestion(question);
					console.log('scrolledDown()')

				} else {
					console.log("not connect to doctor")
					if (incomingChats) {
						// bot to user
						console.log("incoming chats")
						this.setState(
							{
								chat: chat.concat(incomingChats)																	// This is where chat content is updated
							},
							this.scrollDown
						);
					}
				}
				this.setState({ requesting: false });
			})
			.catch((error) => {
				this.setState({ requesting: false });
				console.log(error);
			});
	};

	saveChatStatements(chat) {
		console.log("saving chatStatement")
		const chatToSave = [];
		for (let i = 0; i < chat.length; ++i) {
			let statement = (typeof chat[i].statement === "string")
				? chat[i].statement
				: chat[i].statement[this.state.languageSelected];
			let type = chat[i].type;
			chatToSave.push({ statement, type });
		}
		return chatToSave;
	}

	/*
	 * Runs after answer is entered by the user.
	 * Sets up command execution
	 * Calls setQuestion()
	 * Will update server
	 * Before endchatbotsequence()
	 */
	answerEntered = () => {
		console.log("answerEntered() entered")
		// noinspection JSUnusedLocalSymbols
		const { answers, connectToDoctor, optionSelected,
			answerFormat, questionDetails, tempSelection, questions } = this.state;
		const { type, options } = answerFormat;
		//const textTypeAnswer = ['text', 'tel', 'password', 'email', 'date', 'list'].includes(type);
		let { nextQuestion } = options && typeof options[optionSelected].nextQuestion != 'undefined'
        ? options[optionSelected] : questionDetails;
		const { command } = questionDetails;
		console.debug('nextQuestion = ', nextQuestion, '. command = ', command, '. questionDetails = ', questionDetails)
		console.debug("type =", type, "command = ", command)
		if (typeof nextQuestion === 'undefined' && command) {
			// Next question to be set by command logic
			console.log(answers)
			if (questions === undefined) this.realtime();
			else commands[command](answers, questionDetails, this.setQuestion, tempSelection);
		}
		else if (type === TYPE_ANALYSE && command) {
			// focus on analysing
			const { questions } = this.state;
			if (questions === undefined) this.realtime()
			else commands[command](answers, questionDetails, questions, this.setQuestion);
		}
		else if (nextQuestion === 0) {
			this.endChatbotSequence();
		}
		else if (questions !== undefined && questions.length>0) {
			console.debug(questions)
			// offline scenario
			// nextQuestion has been provided
			const question = this.getQuestionById(nextQuestion);
			this.setQuestion(question);
		}
		// else if (questions === undefined) {
		// 	// realtime
		// 	this.realtime()
		// }
		else {
			// normal scenario. next question is available
			// examples of unhandled scenarios are - list
			// console.error("answerEntered. unhandled scenario")
			console.log('normal answer. answers = ', answers)
			this.realtime()
		}
	};

	/**
	 * End of flow.
	 */
	endChatbotSequence = () => {
		console.log("endChatbotSequence()")
		const { connectToDoctor, optionSelected} = this.state;
		if (connectToDoctor) {
			const lastMessage = {
				en: 'Please look after your health.',
				hi: 'कृपया अपनी सेहत का ख़याल रखें।',
				bn: 'আপনার স্বাস্থ্যের যত্ন নিন'
			};
			if (optionSelected === '0') this.connect();
			else this.enterMessageIntoChat(lastMessage[this.state.languageSelected], 'incoming');
		} else {
			navigator.geolocation.getCurrentPosition(
				this.completedChatbot.bind(this),
				this.completedChatbot.bind(this)
			);
			console.log("got current user location")
		}
	};

	/**
	 * Called on UI, state, etc changes on frontend
	 * Redirects to URLs if needed
	 * Most frequently called
	 * Best for tracking of user behavior
	 * Updates state
	 */
	handleChange = (event) => {
		const { id, value } = event.target;
		const { type } = this.state.answerFormat;

		if (type === TYPE_LIST) {
			this.setState({
				tempSelection: {
					...this.state.tempSelection,
					[id]: !this.state.tempSelection[id]
				}
			});
		}
		else if (event.target.id === 'textOverrideAnswered') {
			// text message overrides other ui inputs
			console.log('textOverrideAnswered')
			this.setState(
				{
					[id]: value
				},
				() => {
					this.answer(null, true);
				}
			);
		}
		else {
			// everything default behavior, update things

			// external site
			let redirectUrl = event.target.getAttribute("data-url")

			this.setState(
				{
					[id]: value
				},
				() => {
					if (type === TYPE_BUTTON) {

						// open external site
						if (redirectUrl) window.open(redirectUrl)

						this.answer();
					}
				}
			);
		}
	};

	handleLanguageChange = (event) => {
    const { id, value } = event.target;
    this.setState(
			{
				[id]: value
			},
			() => {
				// const { languageSelected } = this.state.languageSelected;
				this.scrollDown();
			}
		);
  };

	/*
	 * live chat-bot text communication with server
	 */
	realtime = (state) => {
		console.log("realtime()")
		const { optionSelected, answerFormat, questionDetails, textAnswered, conversation_session_id, answers, patientId, currentQuestion, messageReceivedTimestamp, reset } = this.state;
		const { options } = answerFormat;
		let nextQuestion;
    console.debug('nextQuestion = ', nextQuestion)
		if (options && options[optionSelected].nextQuestion){
			// question has options. type is button
			 nextQuestion = options[optionSelected].nextQuestion
		}
		else {
			// question doesn't have options. other types
			nextQuestion = currentQuestion.nextQuestion
		}
    console.debug('currentQuestion = ', currentQuestion)
		// TODO : check if branch questions (with compute and decisions) are managed well
		// const question = this.getQuestionById(nextQuestion);

		// console.log("questionDetails = ", questionDetails)
		// console.log("textAnswered = ", textAnswered)
		// console.log(optionSelected)
		// console.log("nextQuestion = ", nextQuestion)

		axios
			.post(ENDPOINT + '/api/realtime', {
				currentQuestion,
				optionSelected,
				answerFormat,
				options,
				nextQuestion,
				conversation_session_id,
				answers,
				patient_id: patientId,
				state: state,
				reset,
				duration: Date.now()-messageReceivedTimestamp
			})
			.then((response) => {
				const { question, incomingChats } = response.data;
				console.log('question received = ', question)
				if (question)
					this.setState(
						{
							currentQuestion: question,
							loadingChat: false,
							messageReceivedTimestamp : Date.now(),
							reset: false
						},
						() => {
							console.log("settingQuestion")
							this.setQuestion(question);
						});
				})
				.catch((error) => {
					// this.setState({ loadingChat: false });
				this.scrollDown()
				console.error('realtime post error - ', error)
			})
	}

	imageUpload = (event) => {
		const { questionDetails } = this.state;
		const nextQuestion = questionDetails ? questionDetails.nextQuestion : null;
		const file = event.target.files[0];
		if (!file) return;
		if (!this.socket) console.log("Not connected to doctor's chat");
		this.setState({ uploadingImage: 0.01 });
		const { doctor } = this.state;

		const formData = new FormData();
		formData.append('image', file);

		axios
			.post('/api/image', formData, {
				onUploadProgress: (progressEvent) => {
					this.setState({
						uploadingImage: progressEvent.loaded / progressEvent.total
					});
				}
			})
			.then((response) => {
				const { image } = response.data;
				this.enterMessageIntoChat('chat-img-' + image.filename, OUTGOING_MESSAGE);
				if (this.socket) {
					this.socket.emit('message', { message: 'chat-img-' + image.filename, to: doctor });
				} else if (nextQuestion) {
					this.setQuestion(nextQuestion);
				} else if (nextQuestion === 0) {
					this.endChatbotSequence();
				}
				this.setState({ uploadingImage: 0, ...(image ? { image } : {}) });
			})
			.catch((err) => {
				console.log(err);
				if (nextQuestion) {
					this.setQuestion(nextQuestion);
				}
				this.setState({ uploadingImage: 0 });
			});
	};

	/* Chat history box */
	renderChat = () => {
		const {
			callModal,
			chat,
			answerBoxHidden,
			incomingTyping,
			loadingChat,
			requesting,
			mute
		} = this.state;

		if (loadingChat) return null;
		console.log("chat.length = ", chat.length)
		console.log("chat = ", chat)
		return (
			<div id="chat-box" className="chat-box" style={answerBoxHidden ? { marginBottom: 0 } : {}}>
				{chat.map(({ statement, type }) => {
					// latest message render
          const chatStatement = (typeof statement === 'string') ? statement : statement[this.state.languageSelected];
					return (
						<p
							key={{chatStatement}}
							className={`${type}-message ${type === OUTGOING_MESSAGE ? 'fadeInUp' : 'fadeInRight'}`}
							style={{ animationDelay: type === 'incoming' ? '0.6s' : '0.2s' }}
							onMouseEnter={() => {if (mute === SPEAK_ALL) this.speak(chatStatement, true)}}
							onTouchStart={() => {if (mute === SPEAK_ALL) this.speak(chatStatement, true)}}
							onMouseLeave={() => window.speechSynthesis.cancel()}
						>
							{(typeof statement === 'string') && statement.startsWith('chat-img') ? (
								<img src={'/api/images/' + statement.split('-')[2]} alt=''/>
							) : (chatStatement)}
							{statement.description_image && <img src={require("../data/" + statement.description_image)} alt=''/>}
						</p>
					);
				})}
				{incomingTyping || requesting ? (
					<p className="incoming-message">
						<div class="dots">
							<div class="dot"/>
							<div class="dot"/>
							<div class="dot"/>
						</div>
					</p>
				) : null}
				<CallModal status={callModal} startCall={this.startCall} rejectCall={this.rejectCall} />
			</div>
		);
	};

	speak(chatStatement, stopOldSpeach=true) {
		// console.log("speaking ", chatStatement)
		if (stopOldSpeach) window.speechSynthesis.cancel()
		const msg = new SpeechSynthesisUtterance()
		msg.text = chatStatement.replace(/([\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2011-\u26FF]|\uD83E[\uDD10-\uDDFF])/g, '');
		// msg.volume = 1;
		msg.lang = this.state.languageSelected
		window.speechSynthesis.speak(msg);
		// console.log("speechSynthesis.speaking = ", window.speechSynthesis.speaking, "stopSpeaking = ", stopOldSpeach)
		window.speechSynthesis.resume()
	}

	textAnswerOverrides = (event) => {
		const answerFormat = this.state.answerFormat;
		answerFormat.type = TYPE_TEXT
		this.setState({answerFormat})
		this.state.textAnswered = this.state.textOverrideAnswered
		this.state.textOverrideAnswered = ''
		this.setState(this.state)
		this.answer(event)
	};

	/*
	 * Create UI for when user wants to text instead of button, etc.
	 * Used in TYPE_LIST, TYPE_BUTTON, TYPE_SELECT, TYPE_UPLOAD
	 */
	renderTextOverrideMessage = () => {
		const { textOverrideAnswered } = this.state;
		const { pattern } = this.state.answerFormat;

		return (
			<div className="answer-box text-row fadeInUp" style={{ animationDelay: '1s' }}>
				<form onSubmit={this.textAnswerOverrides} className="message-form">
					<input
						id="textOverrideAnswered"
						value={textOverrideAnswered}
						onChange={this.handleChange}
						type={TYPE_TEXT}
						pattern={pattern}
						autoComplete="off"
						autoCorrect="off"
						spellCheck="false"
						onFocus={this.scrollDown}
					/>
					<button type="submit" className="send">
						<Icon.Send />
					</button>
				</form>
			</div>
		)
	}

	/* User inputs */
	renderAnswers = () => {
		const {
			optionSelected,
			textAnswered,
			answerBoxHidden,
			doctor,
			loadingChat,
			uploadingImage
		} = this.state;
		const { options, type, pattern } = this.state.answerFormat;

		const callWithVideo = (video) => {
			const config = { audio: true, video };
			return () => this.startCall(true, config);
		};
		/* no answers allowed */
		if (answerBoxHidden || loadingChat) return null;
		/* chatting with a doctor, so different set of functions */
		else if (uploadingImage) {
			return (
				<div className="answer-box text-row fadeInUp" style={{ animationDelay: '1s' }}>
					<Progress completed={Math.floor(uploadingImage * 100)} />
				</div>
			);
		}
		else if (doctor) {
			return (
				<div className="answer-box text-row fadeInUp" style={{ animationDelay: '1s' }}>
					<form onSubmit={this.sendMessage} className="message-form">
						<input
							id="textAnswered"
							value={textAnswered}
							onChange={this.handleMessageChange}
							type="text"
							autoComplete="off"
							autoCorrect="off"
							spellCheck="false"
							onFocus={this.scrollDown}
						/>
						{textAnswered ? (
							<button type="submit" className="send">
								<Icon.Send />
							</button>
						) : null}
						{!textAnswered ? (
							<button type="button" onClick={callWithVideo(true)} className="send">
								<Icon.Video />
							</button>
						) : null}
						{!textAnswered ? (
							<button type="button" onClick={callWithVideo(false)} className="send">
								<Icon.PhoneCall />
							</button>
						) : null}
						{!textAnswered ? (
							<button
								type="button"
								onClick={() => {
									$('#imageInput').click();
								}}
								className="send"
							>
								<Icon.Image />
							</button>
						) : null}
						<div style={{ width: 0, height: 0, overflow: 'hidden' }}>
							<input
								type="file"
								id="imageInput"
								name="imageInput"
								onChange={this.imageUpload}
								accept="image/*"
							/>
						</div>
					</form>
				</div>
			);
		}
		else if (type === TYPE_BUTTON) {
			/* different types of answer*/
			// User answer buttons
			return (
				<div>
					<div className="answer-box button-row">
						{options.map(({ value, statement, url, skip=false }, index) => {
							let chatStatement = undefined
							if (statement === undefined) chatStatement = undefined
							else chatStatement = (typeof statement === 'string') ? statement : statement[this.state.languageSelected];
							// noinspection HtmlRequiredAltAttribute
							if (skip === undefined) skip=false
							console.log("render.answers answerBoxHidden skip = ", skip, '. value = ', value)
							return (
								<button
									key={value}
									value={value}
									data-url={url}
									id="optionSelected"
									onClick={this.handleChange}
									className="fadeInUp"
									style={{ animationDelay: `1.${index}s`, background: '#CCCCFF', color: '#111111', fontSize: 'large' }}
									onMouseEnter={() => this.speak(chatStatement, false)}
									onTouchStart={() => this.speak(chatStatement, true)}
									hidden={skip}
								>
									{chatStatement}
									{statement && statement.description_image && <img src={require("../data/" + statement.description_image)} style={{
										width: '100%', height: undefined, aspectRatio: 1,  pointerEvents: "none" }} alt={''}/>}
								</button>
							);
						})}
					</div>
					{this.renderTextOverrideMessage()}
				</div>
			);
		}
		else if (type === TYPE_LIST) {
			// checkboxes
			console.log("renderAnswers list")
			return (
				<div>
				<div style={{ display:"flex", "flexDirection":"column" }}>
					<div className="answer-box button-row" style={{ "flexWrap":"wrap" }}>
						{options.map(({ value, statement }, index) => {
	            const chatStatement = (typeof statement === 'string') ? statement : statement[this.state.languageSelected];
							// noinspection HtmlRequiredAltAttribute
							return (
								<label style={{ animationDelay: `1.${index}s`, background: '#CCCCFF', color: '#111111', fontSize: 'large', flex: '1' }}>
									<input type="checkbox"
										id={value}
										onChange={this.handleChange}
										className="fadeInUp"
										style={{ marginRight: "10px", background: '#CCCCFF', color: '#111111', fontSize: 'large' }}
										onMouseEnter={() => this.speak(chatStatement, false)}
										onTouchStart={() => this.speak(chatStatement, true)}
									/>
										{chatStatement}
										{statement.description_image && <img src={require("../data/" + statement.description_image)} style={{
										width: '100%', height: undefined, aspectRatio: 1,  pointerEvents: "none" }}/>}
								</label>
							);
						})}
					</div>
					<button
						onClick={this.answer}
						className="fadeInUp"
						style={{ animationDelay: `2.0s`, background: '#CCCCFF', color: '#111111', fontSize: 'large', position:'relative', whiteSpace:'nowrap' }}
					>
						<object>
						{ this.state.languageSelected==='hi' ? "भेजें" : "SUBMIT" }
							<object height='1px' hspace="5mm"/>
							<Icon.Send/>
						</object>
					</button>
				</div>
					{this.renderTextOverrideMessage()}
				</div>
			);
		}
		else if (type === TYPE_SELECT) {
			 // spinner
			console.log("renderAnswers select")
			return (
				<div>
				<div className="answer-box select-row fadeInUp" style={{ animationDelay: '1s' }}>
					<select id="optionSelected" value={optionSelected} onChange={this.handleChange}>
						{options && options.map(({ value, statement }) => {
              const chatStatement = (typeof statement === 'string') ? statement : statement[this.state.languageSelected];
							return <option value={value}>{chatStatement}</option>;
						})}
					</select>
					<button onClick={this.answer} className="send">
						<Icon.Send />
					</button>
				</div>
					{this.renderTextOverrideMessage()}
				</div>
			);
		} else if (type === TYPE_UPLOAD) {
			// Media upload
			console.log("renderAnswers upload")
      return (
				<div>
        <div className="answer-box text-row fadeInUp" style={{ animationDelay: '1s' }}>
          <form className="message-form">
            <button
              type="button"
              onClick={() => {
                $('#imageInput').click();
              }}
              className="send"
            >
              <Icon.File />
            </button>
            <div style={{ width: 0, height: 0, overflow: 'hidden' }}>
              <input
                type="file"
                id="imageInput"
                name="imageInput"
                onChange={this.imageUpload}
                accept="*/*"
              />
            </div>
          </form>
        </div>
					{this.renderTextOverrideMessage()}
				</div>
			);
		} else {
			 // text field updated but message not sent. send button is to be pressed
			return (
				<div className="answer-box text-row fadeInUp" style={{ animationDelay: '1s' }}>
					<form onSubmit={this.answer} className="message-form">
						<input
							id="textAnswered"
							value={textAnswered}
							onChange={this.handleChange}
							type={type}
							pattern={pattern}
							autoComplete="off"
							autoCorrect="off"
							spellCheck="false"
							onFocus={this.scrollDown}
						/>
						<button type="submit" className="send">
							<Icon.Send />
						</button>
					</form>
				</div>
			);
		}
	};

	resetConversation = (event) => {
		this.state.reset = true
		// this.state.nextQuestion = 1.0
		// this.state.type = 'none'
		this.setState(this.state)
		this.handleChange(event)
	}

	// needs to be implemented properly using speach state and event
	toggleMuter = (event) => {
		const muter = document.getElementById("muter");
		 // TODO : Use set on progress listener
		 if (this.state.mute === MUTE_ALL){
			this.state.mute = SPEAK_ALL
			 const muted = document.getElementById('muted')
			 muted.style.visibility = 'hidden'
			 const speaks = document.getElementById('speaks')
			 speaks.style.visibility = 'visible'
			this.setState(this.state)
		} else if (this.state.mute === SPEAK_ALL){
			this.state.mute = MUTE_ALL
			 window.speechSynthesis.cancel()
			 const muted = document.getElementById('muted')
			 muted.style.visibility = 'visible'
			 const speaks = document.getElementById('speaks')
			 speaks.style.visibility = 'hidden'
			this.setState(this.state)
		}
	}

	/*
	 * Render language selector and chat refresher
	 */
  renderLanguageSelect = () => {
    const {
			languageSelected
		} = this.state;

		return (
      <div className="select-row fadeInUp" style={{ animationDelay: '0.2s' }}>
				<label>Language:</label>
				<select id="languageSelected" value={languageSelected} onChange={this.handleLanguageChange}>
					{languages.map(({ code, name }) => {
						return <option value={code} key={code}>{name}</option>;
					})}
				</select>
				<object height='1px' width="80px"/>
				<Icon.VolumeX id={"muted"} onClick={this.toggleMuter} alt="mute" style={{ visibility: "hidden" }}/>
				<Icon.Volume2 id={"speaks"} onClick={this.toggleMuter} alt="speak" />
				<object height='1px' width="80px"/>
				<Icon.Repeat onClick={this.resetConversation}/>
				<object height='1px' width="20px"  />
      </div>
    );
  };

	render() {
		console.log('render')
		const { loadingChat } = this.state;
		const { callWindow, localSrc, peerSrc } = this.state;

		if (!_.isEmpty(this.config)) {
			return (
				<CallWindow
					status={callWindow}
					localSrc={localSrc}
					peerSrc={peerSrc}
					config={this.config}
					mediaDevice={this.pc.mediaDevice}
					endCall={this.endCall}
				/>
			);
		}

		return (
    <>
      <div className="chat-options expand">
        {this.renderLanguageSelect()}
      </div>
      <div className="Chat fadeInUp" style={{ animationDelay: '0.7s' }}>
        {loadingChat && <div className="lds-dual-ring"/>}
        {this.renderChat()}
				<div style={{ height: '1px', backgroundColor:'grey', boxShadow:'1px 2px 9px grey', marginBottom: '10px' }} />
        {this.renderAnswers()}
      </div>
    </>
		);
	}
}
